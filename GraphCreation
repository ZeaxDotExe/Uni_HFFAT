%%Initialize
clear; clc; close all;
addpath(append(matlabdrive,"\High Frequency Finance and Algorithmic Trading\"));
addpath(append(matlabdrive,"\Code Toolbox\"));
format short

%%

for j = 1:3

%%Data formatting
if j == 1
    data = readtable("EURUSD-hour.csv");
    name = "Hour-by-Hour Data";
elseif j == 2
    data = readtable("EURUSD-minute.csv");
    name = "Minute-by-Minute Data";
elseif j == 3
    data = readtable("EURUSD-tick10.csv");
        name = "Every-10-Ticks Data";
end
data.Return = log(data.Close)-log(lagmatrix(data.Close,1));

data.clock = datetime(append(data.Date,' ',data.Time),"Format","uuuu.MM.dd HH:mm");
data.Time = datetime(data.Time,"Format","HH:mm");
data.Date = datetime(data.Date,"Format","uuuu.MM.dd");

data = sortrows(data,"clock");

subplot(1,3,j)
plot(data.clock,data.Return);
title(name);
xlabel('Time');
ylabel('Return');
grid on;
end 
%% 

for j = 1:3

%%Data formatting
if j == 1
    data = readtable("EURUSD-hour.csv");
    name = "Hour-by-Hour Data";
elseif j == 2
    data = readtable("EURUSD-minute.csv");
    name = "Minute-by-Minute Data";
elseif j == 3
    data = readtable("EURUSD-tick10.csv");
        name = "Every-10-Ticks Data";
end

data.Return = log(data.Close)-log(lagmatrix(data.Close,1));

data.clock = datetime(append(data.Date,' ',data.Time),"Format","uuuu.MM.dd HH:mm");
data.Time = datetime(data.Time,"Format","HH:mm");
data.Date = datetime(data.Date,"Format","uuuu.MM.dd");

data = sortrows(data,"clock");

subplot(1,3,j)
histogram(data.Return,50);
title(name);
end 

%% 

for j = 1:3

%%Data formatting
if j == 1
    data = readtable("EURUSD-hour.csv");
elseif j == 2
    data = readtable("EURUSD-minute.csv");
elseif j == 3
    data = readtable("EURUSD-tick10.csv");
end

data.Return = log(data.Close)-log(lagmatrix(data.Close,1));

data.clock = datetime(append(data.Date,' ',data.Time),"Format","uuuu.MM.dd HH:mm");
data.Time = datetime(data.Time,"Format","HH:mm");
data.Date = datetime(data.Date,"Format","uuuu.MM.dd");

data = sortrows(data,"clock");

subplot(1,3,j)
qqplot(data.Return); % Generates a Q-Q plot of 'data' against the normal distribution
title('Q-Q Plot of Financial Returns vs. Normal Distribution');
xlabel('Theoretical Quantiles (Normal Distribution)');
ylabel('Empirical Quantiles (Returns)');

end 
%% 

for j = 1:3

%%Data formatting
if j == 1
    data = readtable("EURUSD-hour.csv");
    name = "Hour-by-Hour Data";
elseif j == 2
    data = readtable("EURUSD-minute.csv");
    name = "Minute-by-Minute Data";
elseif j == 3
    data = readtable("EURUSD-tick10.csv");
        name = "Every-10-Ticks Data";
end

data.Return = log(data.Close)-log(lagmatrix(data.Close,1));

data.clock = datetime(append(data.Date,' ',data.Time),"Format","uuuu.MM.dd HH:mm");
data.Time = datetime(data.Time,"Format","HH:mm");
data.Date = datetime(data.Date,"Format","uuuu.MM.dd");

data = sortrows(data,"clock");

subplot(1,3,j)
win = 20; %window size
start_i = win+1;
vola = nan(length(data.Return),1);
    for i = start_i:length(data.Return)
        vola(i) = std(data.Return(i-win:i));
    end


plot(data.clock,vola);
title(name);
end
%% 


for j = 1:3

%%Data formatting
if j == 1
    data = readtable("EURUSD-hour.csv");
elseif j == 2
    data = readtable("EURUSD-minute.csv");
elseif j == 3
    data = readtable("EURUSD-tick10.csv");
end

data.Return = log(data.Close)-log(lagmatrix(data.Close,1));

data.clock = datetime(append(data.Date,' ',data.Time),"Format","uuuu.MM.dd HH:mm");
data.Time = datetime(data.Time,"Format","HH:mm");
data.Date = datetime(data.Date,"Format","uuuu.MM.dd");

data = sortrows(data,"clock");

subplot(2,3,j)
autocorr(data.Return);
subplot(2,3,j+3);
parcorr(data.Return);
end
%% 

for j = 1:3

%%Data formatting
if j == 1
    data = readtable("EURUSD-hour.csv");
elseif j == 2
    data = readtable("EURUSD-minute.csv");
elseif j == 3
    data = readtable("EURUSD-tick10.csv");
end

data.Return = log(data.Close)-log(lagmatrix(data.Close,1));

data.clock = datetime(append(data.Date,' ',data.Time),"Format","uuuu.MM.dd HH:mm");
data.Time = datetime(data.Time,"Format","HH:mm");
data.Date = datetime(data.Date,"Format","uuuu.MM.dd");

data = sortrows(data,"clock");

subplot(1,3,j)
%%Memory
[H] = hurstExponentRS(data.Return(2:end));
end


%%Function Hurst Exponents Test
function H = hurstExponentRS(data)
% HURSTEXPONENTRS Estimates the Hurst Exponent using Rescaled Range (R/S) analysis.
%   H = hurstExponentRS(data) estimates the Hurst Exponent for the given time series 'data'.
%   'data' should be a numeric array (vector).

if ~isvector(data) || ~isnumeric(data)
    error('Input data must be a numeric vector.');
end

n = length(data);
if n < 100 % R/S analysis requires sufficient data
    warning('Data length is short for reliable R/S analysis. Consider more data.');
end

% Ensure data is a row vector for easier slicing
if iscolumn(data)
    data = data';
end

max_k = floor(n / 2); % Max block size to use for calculation

log_RS_values = [];
log_k_values = [];

% Iterate through various block sizes (k)
for k = 10:max_k % Start from a reasonable block size
    num_blocks = floor(n / k);
    
    if num_blocks < 2
        continue; % Need at least two blocks to compute RS
    end
    
    RS_sum = 0;
    
    for i = 1:num_blocks
        start_idx = (i-1)*k + 1;
        end_idx = i*k;
        
        block = data(start_idx:end_idx);
        
        % 1. Calculate the mean of the block
        mean_block = mean(block);
        
        % 2. Create the cumulative deviation series
        Y = cumsum(block - mean_block);
        
        % 3. Calculate the range (R)
        R = max(Y) - min(Y);
        
        % 4. Calculate the standard deviation (S)
        S = std(block);
        
        % Avoid division by zero if std is zero (e.g., all values are same)
        if S == 0
            RS_sum = RS_sum + 0; % Or handle as NaN, depending on desired behavior
        else
            RS_sum = RS_sum + (R / S);
        end
    end
    
    % Average RS over all blocks of size k
    avg_RS = RS_sum / num_blocks;
    
    if avg_RS > 0 % Ensure no log of zero/negative
        log_RS_values = [log_RS_values; log(avg_RS)]; %#ok<AGROW>
        log_k_values = [log_k_values; log(k)]; %#ok<AGROW>
    end
end

% Fit a line to log(R/S) vs log(k) to find the slope (Hurst Exponent)
if length(log_k_values) < 2
    H = NaN; % Not enough data points to fit a line
    warning('Not enough valid R/S pairs to estimate Hurst Exponent.');
    return;
end

% Use polyfit to find the slope
coefficients = polyfit(log_k_values, log_RS_values, 1);
H = coefficients(1); % The first coefficient is the slope

% Optional: Plot the log-log plot for visualization
plot(log_k_values, log_RS_values, 'o', 'MarkerFaceColor', 'b');
hold on;
plot(log_k_values, polyval(coefficients, log_k_values), 'r-');
title('R/S Analysis Log-Log Plot');
xlabel('log(k) (Block Size)');
ylabel('log(R/S)');
legend('Data Points', ['Fitted Line (Slope = ', num2str(H, '%.4f'), ')']);
grid on;

end



